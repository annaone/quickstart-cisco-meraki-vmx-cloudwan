AWSTemplateFormatVersion: 2010-09-09
Transform: AWS::Serverless-2016-10-31
Description: >
  This stack is creating creates a step function workflow for meraki cloudWAN.(qs-1srtkbc3l)

Globals:
  Function:
    Handler: app.lambda_handler
    Runtime: python3.8
    Timeout: 900
Parameters:
  QSS3BucketName:
    AllowedPattern: "^[0-9a-zA-Z]+([0-9a-zA-Z-]*[0-9a-zA-Z])*$"
    ConstraintDescription: "Quick Start bucket name can include numbers, lowercase letters, uppercase letters, and hyphens (-). It cannot start or end with a hyphen (-)."
    Default: aws-quickstart
    Description: "S3 bucket name for the Quick Start assets. Quick Start bucket name can include numbers, lowercase letters, uppercase letters, and hyphens (-). It cannot start or end with a hyphen (-)."
    Type: String
  QSS3KeyPrefix:
    AllowedPattern: "^[0-9a-zA-Z-/]*$"
    ConstraintDescription: "Quick Start key prefix can include numbers, lowercase letters, uppercase letters, hyphens (-), and forward slash (/)."
    Default: quickstart-cisco-meraki-sd-wan-vmx/
    Description: "S3 key prefix for the Quick Start assets. Quick Start key prefix can include numbers, lowercase letters, uppercase letters, hyphens (-), and forward slash (/)."
    Type: String
  QSS3BucketRegion:
    Default: 'us-east-1'
    Description: 'The AWS Region where the Quick Start S3 bucket (QSS3BucketName) is hosted. When using your own bucket, you must specify this value.'
    Type: String
  GlobalNetworkName:
    Description: AWS CloudWAN Global Network Name
    Default: "meraki-gn"
    Type: String
  MerakiEventBusName:
    Description: Name of CustomEventBus for EventBridge
    Default: "MerakiEventBus"
    Type: String
  VPCID:
    Description: 'ID of the VPC (e.g., vpc-0343606e)'
    Type: 'AWS::EC2::VPC::Id'
  AvailabilityZone1SubnetID:
    Description: Subnet ID to be used for the deployment of vMX-1 in Availability Zone 1
    Type: 'AWS::EC2::Subnet::Id'
  AvailabilityZone2SubnetID:
    Description: Subnet ID to be used for the deployment of vMX-2 in Availability Zone 2
    Type: 'AWS::EC2::Subnet::Id'
  AmazonASNRange:
    Description: Autonomous System Number (ASN) for CloudWAN Network. 
    Type: String
  

Conditions:
  UsingDefaultBucket: !Equals [!Ref QSS3BucketName, 'aws-quickstart']
  AmazonASNRange: !Equals [!Ref AmazonASNRange, '']

Resources:
##
## Event Bus
  MerakiEventBus:
    Type: AWS::Events::EventBus
    Properties:
      Name: !Ref MerakiEventBusName

##
## Functions  
  CreateGlobalNetworkFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler    
      Runtime: python3.8
      InlineCode: |
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')
        import boto3
        import botocore
        import logging
        import uuid
        import threading
        import json
        

        client = boto3.client('networkmanager')

        # Set up our logger
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger()

        def timeout(event, context):
            logging.error('Execution is about to time out, sending failure response to CloudFormation')
            requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='TableauServerStates',Data='failed due to timeout')).encode('utf-8')
            response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
            sys.exit(1)

        def lambda_handler(event,context):
            timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 2, timeout, args=[event, context])
            timer.start()
            print('Received event: %s' % json.dumps(event))

            try: 
                logger.info('Creatng a global network for Meraki cloudwan')
                id = uuid.uuid1()
                network_name = event['network_name'] + "-" + str(id)[:8]
                #network_name = default_network_name + "-" + str(id)[:8]
                global_network = client.create_global_network(
                    Description='meraki global network',
                    Tags=[
                        {
                            'Key': 'Name',
                            'Value': network_name 
                        }
                    ]
                )
                global_network_id = global_network['GlobalNetwork']['GlobalNetworkId']

            except botocore.exceptions.ClientError as e:
              logging.error('Exception: %s' % e, exc_info=True)
              requests_data=json.dumps(dict(Status='FAILURE',Reason='Exception: %s' % e,UniqueId='GlobalNetworkStates',Data=event['ResourceProperties'])).encode('utf-8')
              response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
              print (response)
              timer.cancel()
            return global_network_id
        
      Policies:
      - AWSNetworkManagerFullAccess
  
  DescribeGlobalNetworksFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler    
      Runtime: python3.8
      InlineCode: |
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')
        import boto3
        import botocore
        import logging
        import threading
        import json
        

        client = boto3.client('networkmanager')

        # Set up our logger
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger()

        def timeout(event, context):
            logging.error('Execution is about to time out, sending failure response to CloudFormation')
            requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='TableauServerStates',Data='failed due to timeout')).encode('utf-8')
            response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
            sys.exit(1)

        def lambda_handler(event,context):
            timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 2, timeout, args=[event, context])
            timer.start()
            print('Received event: %s' % json.dumps(event))

            try: 
              logger.info('Describing global network for Meraki cloudwan')
              response = client.describe_global_networks(
                  GlobalNetworkIds=[event['GlobalNetworkId']]
              )

            except botocore.exceptions.ClientError as e:
              logging.error('Exception: %s' % e, exc_info=True)
              requests_data=json.dumps(dict(Status='FAILURE',Reason='Exception: %s' % e,UniqueId='GlobalNetworkStates',Data=event['ResourceProperties'])).encode('utf-8')
              response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
              print (response)
              timer.cancel()

            return response['GlobalNetworks'][0]['State']
      Policies:
      - AWSNetworkManagerFullAccess
  
  CreateCoreNetworkFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler    
      Runtime: python3.8
      InlineCode: |
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')        
        import boto3
        import botocore
        import logging
        import uuid
        import threading
        import json
        

        client = boto3.client('networkmanager')

        # Set up our logger
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger()

        def timeout(event, context):
            logging.error('Execution is about to time out, sending failure response to CloudFormation')
            requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='TableauServerStates',Data='failed due to timeout')).encode('utf-8')
            response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
            sys.exit(1)

        def lambda_handler(event,context):
            timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 2, timeout, args=[event, context])
            timer.start()
            print('Received event: %s' % json.dumps(event))

            try: 
                logger.info('Creatng a core network for Meraki cloudwan')
                id = uuid.uuid1()
                network_name = event['GlobalNetworkId'] + "-" + 'core-network'
                core_network = client.create_core_network(
                    GlobalNetworkId = event['GlobalNetworkId'],
                    Description='meraki core network',
                    Tags=[
                        {
                            'Key': 'Name',
                            'Value': network_name 
                        },
                    ]
                )
                core_network_id = core_network['CoreNetwork']['CoreNetworkId']
            
            except botocore.exceptions.ClientError as e:
              logging.error('Exception: %s' % e, exc_info=True)
              requests_data=json.dumps(dict(Status='FAILURE',Reason='Exception: %s' % e,UniqueId='GlobalNetworkStates',Data=event['ResourceProperties'])).encode('utf-8')
              response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
              print (response)
              timer.cancel()
            
            return core_network_id
      Policies:
      - AWSNetworkManagerFullAccess
  
  DescribeCoreNetworksFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler    
      Runtime: python3.8
      InlineCode: |
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')
        import boto3
        import botocore
        import logging
        import threading
        import json
        

        client = boto3.client('networkmanager')

        # Set up our logger
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger()

        def timeout(event, context):
            logging.error('Execution is about to time out, sending failure response to CloudFormation')
            requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='TableauServerStates',Data='failed due to timeout')).encode('utf-8')
            response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
            sys.exit(1)

        def lambda_handler(event,context):
            print('Event: {}'.format(event))
            timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 2, timeout, args=[event, context])
            timer.start()

            try:
              logger.info('Describing global network for Meraki cloudwan')
              response = client.get_core_network(
                  CoreNetworkId=event['CoreNetworkId']
              )
            except botocore.exceptions.ClientError as e:
              logging.error('Exception: %s' % e, exc_info=True)
              requests_data=json.dumps(dict(Status='FAILURE',Reason='Exception: %s' % e,UniqueId='GlobalNetworkStates',Data=event['ResourceProperties'])).encode('utf-8')
              response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
              print (response)
              timer.cancel()

            return response['CoreNetwork']['State']
      Policies:
      - AWSNetworkManagerFullAccess
  
  UpdateNetworkPolicyFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler    
      Runtime: python3.8
      InlineCode: |
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')
        import boto3
        import botocore
        import logging
        import json
        import threading
        

        client = boto3.client('networkmanager')

        # Set up our logger
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger()

        def generate_network_policy(event): 
            #fetch latest existing network policy document
            response = client.list_core_network_policy_versions(CoreNetworkId = event['CoreNetworkId'])
            if response['CoreNetworkPolicyVersions'] != []:
                policy_response = client.get_core_network_policy(CoreNetworkId = event['CoreNetworkId'], Alias = 'LATEST')
                policy = json.loads(policy_response['CoreNetworkPolicy']['PolicyDocument'])
            #create a new default policy skeleton
            else:
                policy = {}
                policy['version'] = "2021.12"
                policy['core-network-configuration'] = {
                    'asn-ranges': []
                }
                policy['core-network-configuration'] = {
                    'edge-locations': []
                }
                policy['segments'] = [
                    {
                        'name': 'sdwan',
                        'require-attachment-acceptance': False
                    }
                ]
                policy['segment-actions'] = [
                    {
                        'action': "create-route",
                        'segment': 'sdwan',
                        'destination-cidr-blocks': [],
                        'destinations': ['blackhole'],
                        'description': 'create route for branch traffic to go out via SD-WAN VPC Attachment'
                    },
                    {
                        'action': 'share',
                        'mode': 'attachment-route',
                        'segment': 'sdwan',
                        'share-with': '*'
                    }
                ]
                policy['attachment-policies'] = [
                    {
                        'rule-number': 100,
                        'conditions': [
                            {
                                'type': 'tag-value',
                                'key': 'name',
                                'operator': 'contains',
                                'value': 'Meraki-SDWAN-VPC'
                            }
                        ],
                        'action': {
                            'association-method': 'constant',
                            'segment': 'sdwan'
                        }
                    }
                ]

            #add the policy changes
            if 'asn-range' in event.keys():
                if event['asn-range']: 
                    policy['core-network-configuration']['asn-ranges'] = event['asn-range']

            if 'region' in event.keys():
                region_list = policy['core-network-configuration']['edge-locations']
                region_list.append({'location': event['region']}) 
                policy['core-network-configuration']['edge-locations'] = region_list

            # Q: How does one get region awareness for new branches discovered
            # as an enhancement, may want to implement the case to create a new route when one doesn't exist on an existing policy
            if 'destination_cidr_blocks' in event.keys():
                # append to destination-cidr-blocks in create-route action only for 'sdwan' segment
                for action in policy['segment-actions']:
                    # does create-route action exist?
                    if action['action'] == 'create-route':
                        # append cidr if 'sdwan segment exists
                        if action['segment'] == 'sdwan':
                            for cidr in event['destination_cidr_blocks']:
                                action['destination-cidr-blocks'].append(cidr)

            if 'Destinations' in event.keys():
                # if create-route segment-action exists, append destination if no 'blackhole' exists otherwise replace 'blackhole'
                for action in policy['segment-actions']:
                    if action['action'] == 'create-route':
                        # append destinaciont only to 'sdwan' segment exists
                        if action['segment'] == 'sdwan':
                            if action['destinations'] == ['blackhole']:
                                action['destinations'] = [event['Destinations']]
                            else:
                                for destination in event['Destinations']:
                                    action['destinations'].append(destination)

            # as an enhancement, may want to implement the case to create a new attachment policy when one doesn't exist on an existing policy
        
            return policy

        def timeout(event, context):
            logging.error('Execution is about to time out, sending failure response to CloudFormation')
            requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='TableauServerStates',Data='failed due to timeout')).encode('utf-8')
            response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
            sys.exit(1)

        def lambda_handler(event,context):
            timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 2, timeout, args=[event, context])
            timer.start()
            print('Received event: %s' % json.dumps(event))

            try: 
                logger.info('Attaching network policy document to Meraki cloudwan core network')
                network_policy = generate_network_policy(event)
                print(network_policy)
                print(json.dumps(network_policy))
                response = client.put_core_network_policy(
                    CoreNetworkId=event['CoreNetworkId'],
                    PolicyDocument= json.dumps(network_policy)
                )

                network_policy_version_id = response['CoreNetworkPolicy']['PolicyVersionId']

            except botocore.exceptions.ClientError as e:
              logging.error('Exception: %s' % e, exc_info=True)
              requests_data=json.dumps(dict(Status='FAILURE',Reason='Exception: %s' % e,UniqueId='GlobalNetworkStates',Data=event['ResourceProperties'])).encode('utf-8')
              response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
              print (response)
              timer.cancel()

            return network_policy_version_id
      Policies:
      - AWSNetworkManagerFullAccess
      - AdministratorAccess
  ExecuteCoreNetworkChangeSetFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler    
      Runtime: python3.8
      InlineCode: |
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')   
        import boto3
        import botocore
        import logging
        import uuid
        import threading
        import json
        

        client = boto3.client('networkmanager')

        # Set up our logger
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger()

        def timeout(event, context):
            logging.error('Execution is about to time out, sending failure response to CloudFormation')
            requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='TableauServerStates',Data='failed due to timeout')).encode('utf-8')
            response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
            sys.exit(1)

        def lambda_handler(event,context):
            timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 2, timeout, args=[event, context])
            timer.start()
            print('Received event: %s' % json.dumps(event))

            try: 
                logger.info('executing network policy version ' + str(event['NetworkPolicyVersionId']))
                response = client.execute_core_network_change_set(
                    CoreNetworkId = event['CoreNetworkId'],
                    PolicyVersionId = event['NetworkPolicyVersionId']
                )

            except botocore.exceptions.ClientError as e:
              logging.error('Exception: %s' % e, exc_info=True)
              requests_data=json.dumps(dict(Status='FAILURE',Reason='Exception: %s' % e,UniqueId='GlobalNetworkStates',Data=event['ResourceProperties'])).encode('utf-8')
              response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
              print (response)
              timer.cancel()

            return response
      Policies:
      - AWSNetworkManagerFullAccess
      - AdministratorAccess

  GetNetworkPolicyFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler    
      Runtime: python3.8
      InlineCode: |
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')
        import boto3
        import botocore
        import logging
        import threading
        import json
        

        client = boto3.client('networkmanager')

        # Set up our logger
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger()

        def timeout(event, context):
            logging.error('Execution is about to time out, sending failure response to CloudFormation')
            requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='TableauServerStates',Data='failed due to timeout')).encode('utf-8')
            response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
            sys.exit(1)

        def lambda_handler(event,context):
            timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 2, timeout, args=[event, context])
            timer.start()
            print('Received event: %s' % json.dumps(event))

            try:
              logger.info('Describing global network network policy for Meraki cloudwan')
              response = client.get_core_network_policy(
                  CoreNetworkId=event['CoreNetworkId'],
                  PolicyVersionId=event['NetworkPolicyVersionId']
              )

            except botocore.exceptions.ClientError as e:
              logging.error('Exception: %s' % e, exc_info=True)
              requests_data=json.dumps(dict(Status='FAILURE',Reason='Exception: %s' % e,UniqueId='GlobalNetworkStates',Data=event['ResourceProperties'])).encode('utf-8')
              response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
              print (response)
              timer.cancel()

            return response['CoreNetworkPolicy']['ChangeSetState']
      Policies:
      - AWSNetworkManagerFullAccess
      - AWSAccountManagementReadOnlyAccess
  
  CreateVpcAttachmentFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler    
      Runtime: python3.8
      InlineCode: |
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/') 
        import boto3
        import botocore
        import logging
        import uuid
        import threading
        import json
        

        client = boto3.client('networkmanager')

        # Set up our logger
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger()

        def timeout(event, context):
            logging.error('Execution is about to time out, sending failure response to CloudFormation')
            requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='TableauServerStates',Data='failed due to timeout')).encode('utf-8')
            response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
            sys.exit(1)

        def lambda_handler(event,context):
            timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 2, timeout, args=[event, context])
            timer.start()
            print('Received event: %s' % json.dumps(event))

            try: 
                logger.info('Creating sdwan vpc attachment')
                response = client.create_vpc_attachment(
                    CoreNetworkId=event['CoreNetworkId'],
                    VpcArn=event['VpcArn'],
                    SubnetArns=event['SubnetArns'],
                    Tags=[
                        {
                            'Key': 'name',
                            'Value': 'Meraki-SDWAN-VPC'
                        },
                    ],
                )
                VpcAttachmentId = response['VpcAttachment']['Attachment']['AttachmentId']

            except botocore.exceptions.ClientError as e:
              logging.error('Exception: %s' % e, exc_info=True)
              requests_data=json.dumps(dict(Status='FAILURE',Reason='Exception: %s' % e,UniqueId='GlobalNetworkStates',Data=event['ResourceProperties'])).encode('utf-8')
              response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
              print (response)
              timer.cancel()
            return VpcAttachmentId
      Policies:
      - AWSNetworkManagerFullAccess
      - AdministratorAccess
  
  GetVpcAttachmentFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri:
         Handler: index.lambda_handler    
      Runtime: python3.8
      InlineCode: |
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')
        import boto3
        import botocore
        import logging
        import threading
        import json
        

        client = boto3.client('networkmanager')

        # Set up our logger
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger()

        def timeout(event, context):
            logging.error('Execution is about to time out, sending failure response to CloudFormation')
            requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='TableauServerStates',Data='failed due to timeout')).encode('utf-8')
            response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
            sys.exit(1)

        def lambda_handler(event,context):
            timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 2, timeout, args=[event, context])
            timer.start()
            print('Received event: %s' % json.dumps(event))

            try:
              logger.info('Describing global network network policy for Meraki cloudwan')
              response = client.get_vpc_attachment(
                  AttachmentId=event['Destinations'],
              )
            except botocore.exceptions.ClientError as e:
              logging.error('Exception: %s' % e, exc_info=True)
              requests_data=json.dumps(dict(Status='FAILURE',Reason='Exception: %s' % e,UniqueId='GlobalNetworkStates',Data=event['ResourceProperties'])).encode('utf-8')
              response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
              print (response)
              timer.cancel()

            return response['VpcAttachment']['Attachment']['State']
      Policies:
      - AWSNetworkManagerFullAccess
      - AWSAccountManagementReadOnlyAccess
  CallbackLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Sends callback to CloudFormation to continue after Delete Step FUnction
      Code:
        ZipFile: !Sub |
          import boto3
          import json
          import threading
          
          from botocore.vendored import requests

          def handler(event, context):
            print('Received event: %s' % json.dumps(event))
            print(event['ResourceProperties']['WaitHandle'])
            try:
              requests_data=json.dumps(dict(Status='SUCCESS',Reason='Step Function Succeeded',UniqueId='12345',Data=event['ResourceProperties'])).encode('utf-8')
              response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''}) 
              print (response)
            except Exception as e:
              print (e)
      Handler: index.handler
      Runtime: python3.6
      Role: !GetAtt CallbackRole.Arn
      Timeout: 300

  CallbackRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Path: "/"
##
## State Machines
  CreateStateMachine:
    Type: AWS::Serverless::StateMachine
    DependsOn: 
    - CallbackLambda
    - CreateGlobalNetworkFunction
    - DescribeGlobalNetworksFunction
    - CreateCoreNetworkFunction
    - DescribeCoreNetworksFunction
    - UpdateNetworkPolicyFunction
    - ExecuteCoreNetworkChangeSetFunction
    - GetNetworkPolicyFunction
    Properties:
      Definition:
        Comment: State machine to create meraki cloudwan global network
        StartAt: Create global network
        States:
          Create global network:
            Type: Task
            Resource: !GetAtt CreateGlobalNetworkFunction.Arn
            ResultPath: $.GlobalNetworkId
            Next: Wait 10 seconds for global network
          Wait 10 seconds for global network:
            Type: Wait
            Seconds: 10
            Next: Get global network status
          Get global network status:
            Type: Task
            Resource: !GetAtt DescribeGlobalNetworksFunction.Arn
            ResultPath: $.GlobalNetworkStatus
            Next: Global network created?
          Global network created?:
            Type: Choice
            Choices:
            - Variable: "$.GlobalNetworkStatus"
              StringEquals: AVAILABLE
              Next: Create core network
            Default: Wait 10 seconds for global network
          Create core network:
            Type: Task
            Resource: !GetAtt CreateCoreNetworkFunction.Arn
            ResultPath: $.CoreNetworkId
            Next: Wait 10 seconds for core network
          Wait 10 seconds for core network:
            Type: Wait
            Seconds: 10
            Next: Get core network status
          Get core network status:
            Type: Task
            Resource: !GetAtt DescribeCoreNetworksFunction.Arn
            ResultPath: $.CoreNetworkStatus
            Next: Core network created?
          Core network created?:
            Type: Choice
            Choices:
            - Variable: "$.CoreNetworkStatus"
              StringEquals: AVAILABLE
              Next: Define network policy
            Default: Wait 10 seconds for core network
          Define network policy:
            Type: Task
            Resource: !GetAtt UpdateNetworkPolicyFunction.Arn
            ResultPath: $.NetworkPolicyVersionId
            Next: Wait 10 seconds for network policy
          Wait 10 seconds for network policy:
            Type: Wait
            Seconds: 10
            Next: Get policy status
          Get policy status:
            Type: Task
            Resource: !GetAtt GetNetworkPolicyFunction.Arn
            ResultPath: $.NetworkPolicyChangeSetState
            Next: Network policy ready to execute?
          Network policy ready to execute?:
            Type: Choice
            Choices:
            - Variable: "$.NetworkPolicyChangeSetState"
              StringEquals: READY_TO_EXECUTE
              Next: Execute network policy changeset
            Default: Wait 10 seconds for network policy
          Execute network policy changeset:
            Type: Task
            Resource: !GetAtt ExecuteCoreNetworkChangeSetFunction.Arn
            ResultPath: $.ChangeSetResponse
            Next: Wait 60 seconds for execute network policy changeset
          Wait 60 seconds for execute network policy changeset:
            Type: Wait
            Seconds: 60
            Next: Get network policy changeset status
          Get network policy changeset status:
            Type: Task
            Resource: !GetAtt GetNetworkPolicyFunction.Arn
            ResultPath: $.NetworkPolicyChangeSetState
            Next: Network policy change set executed?
          Network policy change set executed?:
            Type: Choice
            Choices:
            - Variable: "$.NetworkPolicyChangeSetState"
              StringEquals: EXECUTION_SUCCEEDED
              Next: CallBack Lambda
            Default: Wait 60 seconds for execute network policy changeset
          CallBack Lambda:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              Payload.$: "$"
              FunctionName: !GetAtt CallbackLambda.Arn
            Retry:
            - ErrorEquals:
              - Lambda.ServiceException
              - Lambda.AWSLambdaException
              - Lambda.SdkClientException
              IntervalSeconds: 2
              MaxAttempts: 6
              BackoffRate: 2
            End: true
            ResultPath: "$.callback"
          
      Policies:
      - LambdaInvokePolicy:
          FunctionName: !Ref CreateGlobalNetworkFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref DescribeGlobalNetworksFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref CreateCoreNetworkFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref DescribeCoreNetworksFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref UpdateNetworkPolicyFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref GetNetworkPolicyFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref ExecuteCoreNetworkChangeSetFunction
      
      Events:
        CreateNetworkRule:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref MerakiEventBus
            InputPath: $.detail
            Pattern:
              source:
                - com.aws.merakicloudwanquickstart
              detail-type:
                - new meraki global network requested
              account:
                - !Ref AWS::AccountId
                
  CreateNetworkNewRegion:
    Type: AWS::Serverless::StateMachine
    DependsOn:
    - CallbackLambda
    - CreateVpcAttachmentFunction
    - GetVpcAttachmentFunction
    - UpdateNetworkPolicyFunction
    - ExecuteCoreNetworkChangeSetFunction
    - GetNetworkPolicyFunction
    Properties:
      Definition:
          Comment: State machine to update meraki global cloudwan network with additional region
          StartAt: Create Vpc Attachment
          States:
            Create Vpc Attachment:
              Type: Task
              Resource: !GetAtt CreateVpcAttachmentFunction.Arn
              ResultPath: $.Destinations
              Next: Wait 60 seconds for attachment creation
            Wait 60 seconds for attachment creation:
              Type: Wait
              Seconds: 60
              Next: Get vpc attachment status 
            Get vpc attachment status:
              Type: Task
              Resource: !GetAtt GetVpcAttachmentFunction.Arn
              ResultPath: $.VpcAttachmentState
              Next: Ready to update network policy?
            Ready to update network policy?:
              Type: Choice
              Choices:
              - Variable: "$.VpcAttachmentState"
                StringEquals: AVAILABLE
                Next: Update network policy with attachment
              Default: Wait 60 seconds for attachment creation
            Update network policy with attachment:
              Type: Task
              Resource: !GetAtt UpdateNetworkPolicyFunction.Arn
              Parameters:
                Destinations.$: "$.Destinations"
                CoreNetworkId.$: "$.CoreNetworkId"
              ResultPath: $.NetworkPolicyVersionId
              Next: Wait 10 seconds for attachment network policy
            Wait 10 seconds for attachment network policy:
              Type: Wait
              Seconds: 10
              Next: Get attachment network policy status
            Get attachment network policy status:
              Type: Task
              Resource: !GetAtt GetNetworkPolicyFunction.Arn
              ResultPath: $.NetworkPolicyChangeSetState
              Next: Attachment Network policy ready?
            Attachment Network policy ready?:
              Type: Choice
              Choices:
              - Variable: "$.NetworkPolicyChangeSetState"
                StringEquals: READY_TO_EXECUTE
                Next: Execute core network changeset with attachment
              Default: Wait 10 seconds for attachment network policy
            Execute core network changeset with attachment:
              Type: Task
              Resource: !GetAtt ExecuteCoreNetworkChangeSetFunction.Arn
              ResultPath: $.ChangeSetResponse
              Next: Wait 60 seconds for execute core network changeset with attachment
            Wait 60 seconds for execute core network changeset with attachment:
              Type: Wait
              Seconds: 60
              Next: Get attachment network policy changeset status
            Get attachment network policy changeset status:
              Type: Task
              Resource: !GetAtt GetNetworkPolicyFunction.Arn
              ResultPath: $.NetworkPolicyChangeSetState
              Next: Attachment network policy change set ready to execute?
            Attachment network policy change set ready to execute?:
              Type: Choice
              Choices:
              - Variable: "$.NetworkPolicyChangeSetState"
                StringEquals: EXECUTION_SUCCEEDED
                Next: CallBack Lambda
              Default: Wait 60 seconds for execute core network changeset with attachment
            CallBack Lambda:
              Type: Task
              Resource: arn:aws:states:::lambda:invoke
              Parameters:
                Payload.$: "$"
                FunctionName: !GetAtt CallbackLambda.Arn
              Retry:
              - ErrorEquals:
                - Lambda.ServiceException
                - Lambda.AWSLambdaException
                - Lambda.SdkClientException
                IntervalSeconds: 2
                MaxAttempts: 6
                BackoffRate: 2
              End: true
              ResultPath: "$.callback"
      Policies:
      - LambdaInvokePolicy:
          FunctionName: !Ref UpdateNetworkPolicyFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref GetNetworkPolicyFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref ExecuteCoreNetworkChangeSetFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref CreateVpcAttachmentFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref GetVpcAttachmentFunction
      
      Events:
        NewRegionRule:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref MerakiEventBus
            InputPath: $.detail
            Pattern:
              source:
                - com.aws.merakicloudwanquickstart
              detail-type:
                - new meraki additional region requested
              account:
                - !Ref AWS::AccountId

  UpdateStateMachine:
    Type: AWS::Serverless::StateMachine
    DependsOn:
    - UpdateNetworkPolicyFunction
    - ExecuteCoreNetworkChangeSetFunction
    - GetNetworkPolicyFunction
    Properties:
      Definition:
        Comment: State machine to update meraki cloudwan global network
        StartAt: Update network policy
        States:
          Update network policy:
            Type: Task
            Resource: !GetAtt UpdateNetworkPolicyFunction.Arn
            ResultPath: $.NetworkPolicyVersionId
            Next: Wait 10 seconds for network policy
          Wait 10 seconds for network policy:
            Type: Wait
            Seconds: 10
            Next: Get policy status
          Get policy status:
            Type: Task
            Resource: !GetAtt GetNetworkPolicyFunction.Arn
            ResultPath: $.NetworkPolicyChangeSetState
            Next: Network policy ready to execute?
          Network policy ready to execute?:
            Type: Choice
            Choices:
            - Variable: "$.NetworkPolicyChangeSetState"
              StringEquals: READY_TO_EXECUTE
              Next: Execute core network change set
            Default: Wait 10 seconds for network policy
          Execute core network change set:
            Type: Task
            Resource: !GetAtt ExecuteCoreNetworkChangeSetFunction.Arn
            ResultPath: $.ChangeSetResponse
            Next: Wait 60 seconds for execute core network changeset
          Wait 60 seconds for execute core network changeset:
            Type: Wait
            Seconds: 60
            Next: Get network policy changeset status
          Get network policy changeset status:
            Type: Task
            Resource: !GetAtt GetNetworkPolicyFunction.Arn
            ResultPath: $.NetworkPolicyChangeSetState
            Next: Network policy change set executed?
          Network policy change set executed?:
            Type: Choice
            Choices:
            - Variable: "$.NetworkPolicyChangeSetState"
              StringEquals: EXECUTION_SUCCEEDED
              Next: CallBack Lambda
            Default: Wait 60 seconds for execute core network changeset
          CallBack Lambda:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              Payload.$: "$"
              FunctionName: !GetAtt CallbackLambda.Arn
            Retry:
            - ErrorEquals:
              - Lambda.ServiceException
              - Lambda.AWSLambdaException
              - Lambda.SdkClientException
              IntervalSeconds: 2
              MaxAttempts: 6
              BackoffRate: 2
            End: true
            ResultPath: "$.callback"
      Policies:
      - LambdaInvokePolicy:
          FunctionName: !Ref UpdateNetworkPolicyFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref GetNetworkPolicyFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref ExecuteCoreNetworkChangeSetFunction
      Events:
        UpdateNetworkRule:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref MerakiEventBus
            InputPath: $.detail
            Pattern:
              source:
                - com.aws.merakicloudwanquickstart
              detail-type:
                - update global network requested
              account:
                - !Ref AWS::AccountId



##
## Wait Condition  
  StateMachineWaitCondition:
    Type: AWS::CloudFormation::WaitCondition
    # DependsOn: 
    Properties:
      Handle: !Ref StateMachineWaitHandle
      Timeout: 7200
      Count: 1
  
  StateMachineWaitHandle:
    Type: AWS::CloudFormation::WaitConditionHandle
##
## Custom Resource for Events
  StateMachineCustomResource:
    Type: Custom::CloudWanLambda
    DependsOn: 
    - CloudWanDeleteStepFunction
    - CreateStateMachine
    - UpdateStateMachine
    - CreateNetworkNewRegion
    - MerakiEventBus
    Properties:
      ServiceToken: !GetAtt StateMachineCustomResourceLambda.Arn
      WaitHandle: !Ref StateMachineWaitHandle
      EventBusName: !Ref 'MerakiEventBusName'
      Az1SubnetArn: !Sub
                - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${AZ1SubnetID}
                - AZ1SubnetID: !Ref 'AvailabilityZone1SubnetID'
      Az2SubnetArn: !Sub
                - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${AZ2SubnetID}
                - AZ2SubnetID: !Ref 'AvailabilityZone2SubnetID'
      VPCId: !Ref 'VPCID'
      VPCArn: !Sub 
                - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:vpc/${VPC_ID}
                - VPC_ID: !Ref 'VPCID'
      GlobalNetworkName: !Ref 'GlobalNetworkName'
      ASN_Range: !Ref 'AmazonASNRange'
      #add !Ref globalnetworkname

  StateMachineCustomResourceLambda:
    Type: AWS::Lambda::Function
    DependsOn: CreateStateMachine
    Properties:
      Description: Lambda for StateMachineCustomResource
      Handler: index.handler
      Runtime: python3.6
      Role: !GetAtt StateMachineCustomResourceLambdaRole.Arn
      Timeout: 300
      Code:
        ZipFile: !Sub | 
          import boto3
          import json
          import cfnresponse
          import os
          from botocore.vendored import requests

          region = os.environ['AWS_REGION']

          aws_client = boto3.client('events', region_name=region)

          def handler(event, context):
            print('Received event: %s' % json.dumps(event))
            status = cfnresponse.SUCCESS
            responseData = {}

            EventBusName = event['ResourceProperties']['EventBusName']
            asn_range = event['ResourceProperties']['ASN_Range']
            vpc_arn = event['ResourceProperties']['VPCArn']
            az1_subnet_arns = event['ResourceProperties']['Az1SubnetArn']
            az2_subnet_arns = event['ResourceProperties']['Az2SubnetArn']
            subnet_arns = [az1_subnet_arns, az2_subnet_arns]
            global_network_name = event['ResourceProperties']['GlobalNetworkName']

            try:
              if event['RequestType'] == 'Create':
                response = aws_client.put_events(
                  Entries=[
                  {
                      'Source': 'com.aws.merakicloudwanquickstart',
                      'DetailType': 'new meraki global network requested',
                      'Detail': json.dumps({"network_name": global_network_name, "region": region, "asn-range": [asn_range], "destination_cidr_blocks": ['blackhole'], "VpcArn": vpc_arn, "SubnetArns": [subnet_arns]}),
                      'EventBusName': EventBusName
                  }
                  ]
                )
                print(reponse)
                responseData = response
                 
              elif event['RequestType'] == 'Delete':
                response = ec2.put_events(
                    Entries=[
                    {
                        'Source': 'com.aws.merakicloudwanquickstart',
                        'DetailType': 'delete cloudwan resources requested',
                        'Detail': json.dumps({}),
                        'EventBusName': EventBusName
                    }
                    ]
                )                     
              else:
                print('Nothing to do')                  
            except Exception as e:
              print(e)
              status = cfnresponse.FAILED
            finally:
              cfnresponse.send(event, context, status, responseData)
  
  StateMachineCustomResourceLambdaRole:
      Type: AWS::IAM::Role
      Properties:
        AssumeRolePolicyDocument:
          Version: 2012-10-17
          Statement:
          - Effect: Allow
            Principal:
              Service:
              - lambda.amazonaws.com
            Action:
            - sts:AssumeRole
        ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        Path: "/"
        Policies:
        - PolicyName: root
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
            - Effect: Allow
              Action: "*"
              Resource: "*"




  

##
## Delete State Machine and Function Resources  
  CloudWanDeleteStepFunction:
    Type: AWS::Serverless::StateMachine
    DependsOn: 
    - CallbackLambda
    - DeleteAttachmentsDSMFunction
    - DeleteCoreDSMFunction
    - DeleteGlobalDSMFunction
    - DescribeNetworkDSMFunction
    - GetAttachmentStatusDSMFunction
    - GetCoreStatusDSMFunction
    - MerakiEventBus
    Properties:
      Definition:
        Comment: A description of my state machine
        StartAt: Describe Network
        States:
          Describe Network:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              Payload.$: "$"
              FunctionName: !GetAtt DescribeNetworkDSMFunction.Arn
            Retry:
            - ErrorEquals:
              - Lambda.ServiceException
              - Lambda.AWSLambdaException
              - Lambda.SdkClientException
              IntervalSeconds: 2
              MaxAttempts: 6
              BackoffRate: 2
            Next: Delete Attachments
            ResultPath: "$.networkDetails"
          Delete Attachments:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              Payload.$: "$"
              FunctionName: !GetAtt DeleteAttachmentsDSMFunction.Arn
            Retry:
            - ErrorEquals:
              - Lambda.ServiceException
              - Lambda.AWSLambdaException
              - Lambda.SdkClientException
              IntervalSeconds: 2
              MaxAttempts: 6
              BackoffRate: 2
            Next: Wait 1 minute
            ResultPath: "$.attachmentsDeleteExecuted"
          Wait 1 minute:
            Type: Wait
            Seconds: 10
            Next: Get Attachment Status
          Get Attachment Status:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              Payload.$: "$"
              FunctionName: !GetAtt GetAttachmentStatusDSMFunction.Arn
            Retry:
            - ErrorEquals:
              - Lambda.ServiceException
              - Lambda.AWSLambdaException
              - Lambda.SdkClientException
              IntervalSeconds: 2
              MaxAttempts: 6
              BackoffRate: 2
            Next: Attachments Deleted?
            ResultPath: "$.attachmentStatus"
          Attachments Deleted?:
            Type: Choice
            Choices:
            - Variable: "$.attachmentStatus.Payload"
              StringEquals: DELETED
              Next: Delete Core Network
            Default: Wait 1 minute
          Delete Core Network:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              Payload.$: "$"
              FunctionName: !GetAtt DeleteCoreDSMFunction.Arn
            Retry:
            - ErrorEquals:
              - Lambda.ServiceException
              - Lambda.AWSLambdaException
              - Lambda.SdkClientException
              IntervalSeconds: 2
              MaxAttempts: 6
              BackoffRate: 2
            Next: Wait 5 Minutes
            ResultPath: "$.coreDeleteExecuted"
          Wait 5 Minutes:
            Type: Wait
            Seconds: 10
            Next: Get Core Network Status
          Get Core Network Status:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              Payload.$: "$"
              FunctionName: !GetAtt GetCoreStatusDSMFunction.Arn
            Retry:
            - ErrorEquals:
              - Lambda.ServiceException
              - Lambda.AWSLambdaException
              - Lambda.SdkClientException
              IntervalSeconds: 2
              MaxAttempts: 6
              BackoffRate: 2
            Next: Core Network Deleted?
            ResultPath: "$.coreStatus"
          Core Network Deleted?:
            Type: Choice
            Choices:
            - Variable: "$.coreStatus.Payload"
              StringEquals: DELETED
              Next: Delete Global Network
            Default: Wait 5 Minutes
          Delete Global Network:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              Payload.$: "$"
              FunctionName: !GetAtt DeleteGlobalDSMFunction.Arn
            Retry:
            - ErrorEquals:
              - Lambda.ServiceException
              - Lambda.AWSLambdaException
              - Lambda.SdkClientException
              IntervalSeconds: 2
              MaxAttempts: 6
              BackoffRate: 2
            ResultPath: "$.globalDeleteExecuted"
            Next: CallBack Lambda
          CallBack Lambda:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              Payload.$: "$"
              FunctionName: !GetAtt CallbackLambda.Arn
            Retry:
            - ErrorEquals:
              - Lambda.ServiceException
              - Lambda.AWSLambdaException
              - Lambda.SdkClientException
              IntervalSeconds: 2
              MaxAttempts: 6
              BackoffRate: 2
            End: true
            ResultPath: "$.callback"
      Policies:
      - LambdaInvokePolicy:
          FunctionName: !Ref DescribeNetworkDSMFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref DeleteAttachmentsDSMFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref GetAttachmentStatusDSMFunction
      - LambdaInvokePolicy:
          FunctionName: !Ref DeleteCoreDSMFunction          
      - LambdaInvokePolicy:
          FunctionName: !Ref GetCoreStatusDSMFunction  
      - LambdaInvokePolicy:
          FunctionName: !Ref DeleteGlobalDSMFunction 
      - LambdaInvokePolicy:
          FunctionName: !Ref CallbackLambda 
      Events:
        UpdateNetworkRule:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref MerakiEventBus
            InputPath: $.detail
            Pattern:
              source:
                - com.aws.merakicloudwanquickstart
              detail-type:
                - delete cloudwan resources requested
              # account:
              #   - !Ref AWS::AccountId        

  DeleteAttachmentsDSMFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.8
      InlineCode: |
        import json
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')
        import boto3
        from botocore.vendored import requests

        client = boto3.client('networkmanager')

        def lambda_handler(event, context):
            #print(event)
            print(event['networkDetails']['Payload'])
            attachments = event['networkDetails']['Payload']['Attachments']
            #delete attachments
            #if deleting state, pass , else fail
            for attachment in attachments:
                #print(attachment)
                response = client.delete_attachment(AttachmentId=attachment)
                print(response)
                if response['Attachment']['State'] == 'DELETING':
                    print('DELETING',attachment)
                else:
                    #to-do: error handling
                    print('ERROR',attachment)
                    return('ERROR')

            return('DELETING')
      Policies:
      - AWSNetworkManagerFullAccess
      - AdministratorAccess
      - AmazonEC2ReadOnlyAccess


  DeleteCoreDSMFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler    
      Runtime: python3.8
      InlineCode: |
        import json
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')        
        import boto3
        from botocore.vendored import requests

        client = boto3.client('networkmanager')

        def lambda_handler(event, context):
            print(event['networkDetails']['Payload']['CoreNetworkId'])
            coreNetworkId = event['networkDetails']['Payload']['CoreNetworkId']
            response = client.delete_core_network(CoreNetworkId=coreNetworkId)
            print(response)
            if response['CoreNetwork']['State'] == 'DELETING':
                print('DELETING')
                return('DELETING')
            else:
                #to-dp: write error handling
                print('ERROR')
      Policies:
      - AWSNetworkManagerFullAccess
      - AdministratorAccess
      - AmazonEC2ReadOnlyAccess


  DeleteGlobalDSMFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler 
      Runtime: python3.8   
      InlineCode: |
        import json
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')            
        import boto3
        from botocore.vendored import requests

        client = boto3.client('networkmanager')

        def lambda_handler(event, context):
            globalNetworkId = event['networkDetails']['Payload']['GlobalNetworkId']
            try:
                response = client.delete_global_network(GlobalNetworkId=globalNetworkId)
                print(response)
            
            except Exception as e:
                print(e)
      Policies:
      - AWSNetworkManagerFullAccess
      - AdministratorAccess
      - AmazonEC2ReadOnlyAccess


  DescribeNetworkDSMFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler  
      Runtime: python3.8  
      InlineCode: |
        import json
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')          
        from botocore.vendored import requests
        import boto3

        client = boto3.client('networkmanager')


        def lambda_handler(event, context):
            print('Event: {}'.format(event))
            network={}
            try:
                #get GlobalNetworkID based upon predefined tag
                response = client.describe_global_networks()
                for gn in response['GlobalNetworks']:
                    for tag in gn['Tags']:
                        if tag['Key'] == 'quickstart-control-DO-NOT-MODIFY' and tag['Value'] == 'Meraki CloudWAN Quick Start':
                            print('Global NetworkID: ' + gn['GlobalNetworkId'])
                            print('tag: '+ tag['Key'], tag['Value'])
                            network['GlobalNetworkId'] = gn['GlobalNetworkId']
                
                
                #get the proper core network associated with the GlobalNetworkID
                response = client.list_core_networks()
                for core in response['CoreNetworks']:
                    #is try/except the proper way to do this?
                    #not all items returned will have a global network, so it will throw an error without try/except
                    try: 
                        if core['GlobalNetworkId'] == network['GlobalNetworkId']:
                            #print(core['CoreNetworkId'])
                            network['CoreNetworkId'] = core['CoreNetworkId']
                    except:
                        #print('global network not found')
                        pass
                
                network['Attachments'] = [] #create list to include multiple attachments
                response = client.list_attachments(CoreNetworkId=network['CoreNetworkId'])
                for attachment in response['Attachments']:
                    #print(attachment)
                    try: 
                        if attachment['SegmentName'] == 'sdwan':
                            #print(attachment['AttachmentId'])
                            network['Attachments'].append(attachment['AttachmentId'])
                    except:
                        #print('SegmentName not found')
                        pass                
                
                
                #add error logic if network not found
                print(network)
                return(network)
                
            except Exception as e:
                print(e)
                #requests_data=json.dumps(dict(Status='FAILURE',Reason='Exception: %s' % e,UniqueId='DeleteStateMachine',Data=event['ResourceProperties'])).encode('utf-8')
                #response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                #print (response)    
      Policies:
      - AWSNetworkManagerFullAccess
      - AdministratorAccess
      - AmazonEC2ReadOnlyAccess

  GetAttachmentStatusDSMFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.8
      InlineCode: |
        import json
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')          
        from botocore.vendored import requests
        import boto3

        client = boto3.client('networkmanager')

        def lambda_handler(event, context):
            print(event)
            print(event['networkDetails']['Payload']['CoreNetworkId'])
            coreNetworkId = event['networkDetails']['Payload']['CoreNetworkId']
            response = client.list_attachments(CoreNetworkId=coreNetworkId)
            print(response)
            for attachment in response['Attachments']:
                print(attachment)

            if response['Attachments']:
                print('WAITING')
                return('WAITING')
            else:
                print('DELETED')
                return('DELETED')


      Policies:
      - AWSNetworkManagerFullAccess
      - AdministratorAccess
      - AmazonEC2ReadOnlyAccess

  GetCoreStatusDSMFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.8
      InlineCode: |
        import json
        import sys
        from pip._internal import main
        main(['install', '-I', '-q', 'boto3', '--target', '/tmp/', '--no-cache-dir', '--disable-pip-version-check'])
        sys.path.insert(0,'/tmp/')         
        import boto3
        from botocore.vendored import requests

        client = boto3.client('networkmanager')

        def lambda_handler(event, context):
            coreNetworkId = event['networkDetails']['Payload']['CoreNetworkId']
            response = client.list_core_networks()
            for core in response['CoreNetworks']:
                if core['CoreNetworkId'] == coreNetworkId:
                    print('WAITING')
                    return('WAITING')
            print('DELETED')
            return('DELETED')

      Policies:
      - AWSNetworkManagerFullAccess
      - AdministratorAccess
      - AmazonEC2ReadOnlyAccess


##End of Delete State Machine Resources
##
##

Outputs:
  CreateStateMachine:
    Value: !Ref CreateStateMachine
    Description: Create network Step Function Arn
  UpdateStateMachine:
    Value: !Ref UpdateStateMachine
    Description: Update network Step Function Arn
  CreateNetworkNewRegion:
    Value: !Ref CreateNetworkNewRegion
    Description: Create network additional region Step Function Arn
  MerakiEventBusArn:
    Description: The ARN of the central event bus
    Value: !GetAtt MerakiEventBus.Arn
  
